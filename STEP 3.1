1) Problem statement
Given an array ‘arr’ of size ‘n’ find the largest element in the array.

soluton 

#include <bits/stdc++.h> 
int largestElement(vector<int> &arr, int n) {
    int max = arr[0];
    for(int i = 0 ; i<n ; i++){
        if(max < arr[i]){
            max = arr[i];
        }
    }
    return max;
}


2) Problem statement
You have been given an array ‘a’ of ‘n’ unique non-negative integers.
Find the second largest and second smallest element from the array.
Return the two elements (second largest and second smallest) as another array of size 2.

solution 

int secondLargest( vector<int> a , int n){
    int largest = a[0];
    int slargest = INT_MIN;
    for(int i = 1; i<n; i++){
        if( a[i] > largest){
            slargest = largest;
            largest = a[i];
        }
        else if (a[i] < largest && a[i] > slargest){
            slargest = a[i];
        }
    }
    return slargest;
}
int secondSmallest( vector<int> a , int n){
    int smallest = a[0];
    int ssmallest = INT_MAX;
    for(int i = 1; i<n; i++){
        if( a[i] < smallest){
            ssmallest = smallest;
            smallest = a[i];
        }
        else if (a[i] != smallest && a[i] < ssmallest){
            ssmallest = a[i];
        }
    }
    return ssmallest;
}

vector<int> getSecondOrderElements(int n, vector<int> a) {
    int slargest = secondLargest(a , n);
    int ssmallest = secondSmallest(a,n);
    return{slargest , ssmallest};
}



3) Problem statement
You have been given an array ‘a’ of ‘n’ non-negative integers.You have to check whether the given array is sorted in the non-decreasing order or not.
Your task is to return 1 if the given array is sorted. Else, return 0.

solution 

int isSorted(int n, vector<int> a) {
    for(int i = 0 ; i<n-1 ; i++){
        if(a[i]<=a[i+1]){
            
        }
        else{
            return 0;
        }
    }
    return 1;
}


4) Problem Statment 
Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.
There may be duplicates in the original array.

solution 

class Solution {
public:
    bool check(vector<int>& nums) {
        int count = 0;
        int n = nums.size();
        for(int i =1;i<n;i++){
            if(nums[i-1]>nums[i]){
                count++;
            }
        }
        if(nums[n-1]>nums[0]){
            count++;
        }
        return count<=1;
        
    }
};


5) Problem statement
You are given a sorted integer array 'arr' of size 'n'.
You need to remove the duplicates from the array such that each element appears only once.
Return the length of this new array.

solution 

int removeDuplicates(vector<int> &arr, int n) {
	int size = n;
	for(int i = 0 ; i<n ; i++){
		if(arr[i] == arr[i+1]){
			size--;
		}
	}
	return size;
}


6) Problem Statement 
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.
Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:
Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.

solution 

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int j = 1;
        for(int i = 1 ; i<nums.size() ; i++){
            if(nums[i] != nums[i-1]){
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};


7) Problem statement
Given an array 'arr' containing 'n' elements, rotate this array left once and return it.
Rotating the array left by one means shifting all elements by one place to the left and moving the first element to the last position in the array.

solution 

vector<int> rotateArray(vector<int>& arr, int n) {
    int temp = arr[0];
    for(int i = 1 ; i<n ; i++){
        arr[i-1] = arr[i];
    }
    arr[n-1] = temp;
    return arr;
}



8) Problem Statement 
Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

solution 

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k%n;
        auto a = nums.begin();
        auto b = nums.end();
        reverse(a,b);
        reverse(a,a+k);
        reverse(a+k,b);
    }
};


9) Problem statement
Given an array 'arr' with 'n' elements, the task is to rotate the array to the left by 'k' steps, where 'k' is non-negative.

solution 

vector<int> rotateArray(vector<int>arr, int k) {
    int n = arr.size();
    k = k%n;
    reverse(arr.begin(), arr.begin()+k);
    reverse(arr.begin()+k , arr.end());
    reverse(arr.begin() , arr.end());
    return arr;
}


10) Problem statement 
Given an array 'arr' of 'n' non-negative integers, your task is to move all the zeros to the end of the array while keeping the non-zero elements at the start of the array in their original order. Return the modified array.

solution (brute)

vector<int> moveZeros(int n, vector<int> a) {
    vector<int>  temp;
    for(int i = 0 ; i<n;i++){
        if(a[i] != 0){
            temp.push_back(a[i]);
        }
    }
    int k = temp.size();
    for(int i = 0 ; i<k;i++){
        a[i] = temp[i];
    }
    for(int i = k ; i<n ; i++){
        a[i] = 0;
    }
    return a;
}


11) Problem Statement 
Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.

solution(optimal)

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i = 0;
        for(int j =0;j<nums.size(); j++){
            if(nums[j] != 0){
                swap(nums[j],nums[i]);
                i++;
            }
        }

    }
};


12) Problem statement
You are given an array ‘arr’ containing ‘n’ integers. You are also given an integer ‘num’, and your task is to find whether ‘num’ is present in the array or not.
If ‘num’ is present in the array, return the 0-based index of the first occurrence of ‘num’. Else, return -1.

solution 

int linearSearch(int n, int num, vector<int> &arr)
{
    for(int i = 0 ; i <n ; i++){
        if(arr[i] == num){
            return i;
        }
    }
    return -1;
}


13) Problem statement
Given two sorted arrays, ‘a’ and ‘b’, of size ‘n’ and ‘m’, respectively, return the union of the arrays.
The union of two sorted arrays can be defined as an array consisting of the common and the distinct elements of the two arrays. The final array should be sorted in ascending order.
Note: 'a' and 'b' may contain duplicate elements, but the union array must contain unique elements.

solution 

vector<int> sortedArray(vector<int>& a, vector<int>& b) {
    vector<int> temp;
    int n = a.size();
    int m = b.size();
    int i = 0, j = 0;
    
    while (i < n && j < m) {
        if (a[i] < b[j]) {
            if (i == 0 || a[i] != a[i - 1]) {
                temp.push_back(a[i]);
            }
            i++;
        } else if (a[i] > b[j]) {
            if (j == 0 || b[j] != b[j - 1]) {
                temp.push_back(b[j]);
            }
            j++;
        } else {
            if ((i == 0 || a[i] != a[i - 1]) && (j == 0 || b[j] != b[j - 1])) {
                temp.push_back(a[i]);
            }
            i++;
            j++;
        }
    }
    while (i < n) {
        if (i == 0 || a[i] != a[i - 1]) {
            temp.push_back(a[i]);
        }
        i++;
    }
    while (j < m) {
        if (j == 0 || b[j] != b[j - 1]) {
            temp.push_back(b[j]);
        }
        j++;
    }

    return temp;
}

